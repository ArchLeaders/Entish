using System.Runtime.InteropServices;
using System.Text;
using Entish.SourceGenerator.Extensions;
using Microsoft.CodeAnalysis;

namespace Entish.SourceGenerator.Builders;

public class SwappableBuilder(SourceProductionContext context, Compilation compilation)
{
    private const string SwappableInterfaceTypeName = "Entish.ISwappable`T";
    private const string NeverSwapAttributeTypeName = "Entish.Attributes.NeverSwapAttribute";
    private const string StructLayoutAttributeTypeName = "System.Runtime.InteropServices.StructLayoutAttribute";
    private const string FieldOffsetAttributeTypeName = "System.Runtime.InteropServices.FieldOffsetAttribute";

    private readonly SourceProductionContext _context = context;
    private readonly ISymbol _swappableAttribute = compilation.GetTypeByMetadataName(SwappableGenerator.AttributeTypeName)!;
    private readonly ISymbol _swappableInterface = compilation.GetTypeByMetadataName(SwappableInterfaceTypeName)!;
    private readonly ISymbol _neverSwapAttribute = compilation.GetTypeByMetadataName(NeverSwapAttributeTypeName)!;
    private readonly ISymbol _structLayoutAttribute = compilation.GetTypeByMetadataName(StructLayoutAttributeTypeName)!;
    private readonly ISymbol _fieldOffsetAttribute = compilation.GetTypeByMetadataName(FieldOffsetAttributeTypeName)!;

    public void GenerateSwappable(INamedTypeSymbol symbol)
    {
        if (!symbol.IsUnmanagedType) {
            _context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    "ENTISH-0001",
                    "Invalid swappable type",
                    "Types annotated with SwappableAttribute must be unmanaged structures",
                    "Swappable Generator",
                    DiagnosticSeverity.Error, true),
                symbol.Locations.FirstOrDefault())
            );
            return;
        }

        StringBuilder swapCode = new();
        WriteStructSwapCode(swapCode, symbol);

        string code = $$"""
            // <auto-generated/>

            #nullable enable

            namespace {{symbol.ContainingNamespace}};

            public partial struct {{symbol.Name}} : global::Entish.ISwappable<{{symbol.Name}}>
            {
                public static unsafe void Swap({{symbol.Name}}* target)
                {{{swapCode}}
                }
            }
            """;

        _context.AddSource(
            $"{symbol.ToDisplayString(NullableFlowState.NotNull, SymbolDisplayFormat.MinimallyQualifiedFormat)}.g.cs",
            code);
    }

    public void WriteStructSwapCode(StringBuilder sb, INamedTypeSymbol symbol, string varName = "target")
    {
        IEnumerable<IFieldSymbol> fields = symbol
            .GetMembers()
            .Select(member => (member as IFieldSymbol)!)
            .Where(member => member is not null);

        AttributeData? structLayoutAttribute = symbol
            .GetAttributes()
            .FirstOrDefault(attribute => SymbolEqualityComparer.Default.Equals(attribute.AttributeClass, _structLayoutAttribute));

        if (structLayoutAttribute?.ConstructorArguments.FirstOrDefault() is {
                Kind: TypedConstantKind.Enum,
                Value: (int)LayoutKind.Explicit
            }) {
            // Pick the best fields to swap
            // in the case of a union struct 
            fields = fields.PickOptimalFields(_fieldOffsetAttribute);
        }

        foreach (IFieldSymbol field in fields) {
            WriteFieldSwapCode(sb, field, varName);
        }
    }

    private void WriteFieldSwapCode(StringBuilder sb, IFieldSymbol field, string varName = "target")
    {
        ITypeSymbol fieldType = field.Type;
        
        if (IsSingleByte(fieldType)) {
            return;
        }

        if (field.GetAttributes().Any(x => SymbolEqualityComparer.Default.Equals(x.AttributeClass, _neverSwapAttribute))) {
            return;
        }
        
        if (fieldType is IPointerTypeSymbol ptr) {
            if (IsSingleByte(ptr.PointedAtType)) {
                return;
            }
            
            for (int i = 0; i < field.FixedSize; i++) {
                sb.Append($"""

                            global::Entish.EndianUtils.Swap(&{varName}->{field.Name}[{i}]);
                    """);
            }
            
            return;
        }

        if (IsSimpleType(field.Type, out bool isEnum)) {
            sb.Append($"""

                        global::Entish.EndianUtils.Swap({(isEnum ? $"({((INamedTypeSymbol)field.Type).EnumUnderlyingType?.ToDisplayString(NullableFlowState.NotNull, SymbolDisplayFormat.FullyQualifiedFormat)}*)" : "")}&{varName}->{field.Name});
                """);
            return;
        }

        bool isFieldTypeImplementingSwappable =
            field.Type.GetAttributes().Any(x => SymbolEqualityComparer.Default.Equals(x.AttributeClass, _swappableAttribute)) ||
            field.Type.AllInterfaces.Any(x => SymbolEqualityComparer.Default.Equals(x, _swappableInterface));

        if (isFieldTypeImplementingSwappable) {
            sb.Append($"""

                        {field.Type.ToDisplayString(NullableFlowState.NotNull, SymbolDisplayFormat.FullyQualifiedFormat)}.Swap(&{varName}->{field.Name});
                """);
            return;
        }

        string complexTypeVarName = $"{varName}{field.Name}";
        sb.Append($"""

                    {field.Type.ToDisplayString(NullableFlowState.NotNull, SymbolDisplayFormat.FullyQualifiedFormat)}* {complexTypeVarName} = &{varName}->{field.Name};
            """);
        
        WriteStructSwapCode(sb, (INamedTypeSymbol)field.Type, complexTypeVarName);
    }
    
    private static bool IsSingleByte(ITypeSymbol type)
        => type.SpecialType is SpecialType.System_Byte or SpecialType.System_SByte or SpecialType.System_Boolean;

    private static bool IsSimpleType(ITypeSymbol type, out bool isEnum)
        => (isEnum = type.TypeKind is TypeKind.Enum) || type.SpecialType is
            SpecialType.System_Byte or SpecialType.System_SByte or SpecialType.System_Boolean or
            SpecialType.System_Char or SpecialType.System_Int16 or SpecialType.System_UInt16 or
            SpecialType.System_Int32 or SpecialType.System_UInt32 or SpecialType.System_Single or
            SpecialType.System_Int64 or SpecialType.System_UInt64 or SpecialType.System_Double or
            SpecialType.System_DateTime or SpecialType.System_IntPtr or SpecialType.System_UIntPtr or
            SpecialType.System_Decimal;
}